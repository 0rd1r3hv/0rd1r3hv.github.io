<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MoeCTF 2024 Reverse | Ordirehv's Blog</title><meta name="author" content="Ordirehv"><meta name="copyright" content="Ordirehv"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="好玩！">
<meta property="og:type" content="article">
<meta property="og:title" content="MoeCTF 2024 Reverse">
<meta property="og:url" content="https://0rd1r3hv.github.io/posts/moectf-2024-reverse/">
<meta property="og:site_name" content="Ordirehv&#39;s Blog">
<meta property="og:description" content="好玩！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://0rd1r3hv.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-10-10T13:11:47.000Z">
<meta property="article:modified_time" content="2025-04-18T07:00:00.303Z">
<meta property="article:author" content="Ordirehv">
<meta property="article:tag" content="MoeCTF 2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://0rd1r3hv.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://0rd1r3hv.github.io/posts/moectf-2024-reverse/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MoeCTF 2024 Reverse',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-18 15:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(180deg, rgba(2,0,36,0.5) 90%, rgba(2,0,36,0) 100%);"><nav id="nav"><span id="blog-info"><a href="/" title="Ordirehv's Blog"><span class="site-name">Ordirehv's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MoeCTF 2024 Reverse</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-10T13:11:47.000Z" title="发表于 2024-10-10 21:11:47">2024-10-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-18T07:00:00.303Z" title="更新于 2025-04-18 15:00:00">2025-04-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Reverse/">Reverse</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MoeCTF 2024 Reverse"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="逆向工程入门指北"><a href="#逆向工程入门指北" class="headerlink" title="逆向工程入门指北"></a>逆向工程入门指北</h1><p>已经给出源代码，加密逻辑为异或22，那再异或回来就拿到flag了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enflag = [<span class="number">123</span>, <span class="number">121</span>, <span class="number">115</span>, <span class="number">117</span>, <span class="number">98</span>, <span class="number">112</span>, <span class="number">109</span>, <span class="number">100</span>, <span class="number">37</span>, <span class="number">96</span>, <span class="number">37</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">37</span>, <span class="number">73</span>, <span class="number">39</span>, <span class="number">101</span>, <span class="number">73</span>, <span class="number">119</span>, <span class="number">73</span>, <span class="number">122</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">113</span>, <span class="number">73</span>, <span class="number">122</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">113</span>, <span class="number">73</span>, <span class="number">97</span>, <span class="number">119</span>, <span class="number">111</span>, <span class="number">73</span>, <span class="number">98</span>, <span class="number">121</span>, <span class="number">73</span>, <span class="number">115</span>, <span class="number">110</span>, <span class="number">102</span>, <span class="number">122</span>, <span class="number">121</span>, <span class="number">100</span>, <span class="number">115</span>, <span class="number">107</span>, <span class="number">22</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(x ^ <span class="number">22</span>) <span class="keyword">for</span> x <span class="keyword">in</span> enflag)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># moectf&#123;r3v3rs3_1s_a_long_long_way_to_explore&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h1><p>拖到IDA里F5一下先。</p>
<img src="/posts/moectf-2024-reverse/xor.png" class="" title="xor">
<p>程序比较输入逐字节异或<code>0x24</code>后的结果与<code>0x1400022B8</code>处开始的44字节是否相等。把这些字节异或0x24即可得到flag。</p>
<p>双击跳转到对应内存区域，右键Convert可以把它导出成各种数据类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enflag = [<span class="number">0x49</span>, <span class="number">0x4B</span>, <span class="number">0x41</span>, <span class="number">0x47</span>, <span class="number">0x50</span>, <span class="number">0x42</span>, <span class="number">0x5F</span>, <span class="number">0x41</span>, <span class="number">0x1C</span>, <span class="number">0x16</span>, <span class="number">0x46</span>, <span class="number">0x10</span>, <span class="number">0x13</span>, <span class="number">0x1C</span>, <span class="number">0x40</span>, <span class="number">0x09</span>, <span class="number">0x42</span>, <span class="number">0x16</span>, <span class="number">0x46</span>, <span class="number">0x1C</span>, <span class="number">0x09</span>, <span class="number">0x10</span>, <span class="number">0x10</span>, <span class="number">0x42</span>, <span class="number">0x1D</span>, <span class="number">0x09</span>, <span class="number">0x46</span>, <span class="number">0x15</span>, <span class="number">0x14</span>, <span class="number">0x14</span>, <span class="number">0x09</span>, <span class="number">0x17</span>, <span class="number">0x16</span>, <span class="number">0x14</span>, <span class="number">0x41</span>, <span class="number">0x40</span>, <span class="number">0x40</span>, <span class="number">0x16</span>, <span class="number">0x14</span>, <span class="number">0x47</span>, <span class="number">0x12</span>, <span class="number">0x40</span>, <span class="number">0x14</span>, <span class="number">0x59</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(x ^ <span class="number">0x24</span>) <span class="keyword">for</span> x <span class="keyword">in</span> enflag)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># moectf&#123;e82b478d-f2b8-44f9-b100-320edd20c6d0&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="upx"><a href="#upx" class="headerlink" title="upx"></a>upx</h1><p>先拖到DIE里看看。正如标题所言，程序使用了upx压缩。</p>
<img src="/posts/moectf-2024-reverse/upx.png" class="" title="upx">
<p>咱们先<code>upx -d</code>脱一下壳，然后拖到IDA里。</p>
<img src="/posts/moectf-2024-reverse/upx2.png" class="" title="upx2">
<p>嘿！直接把flag告诉咱了。</p>
<p><code>moectf&#123;ec5390dd-f8cf-4b02-bc29-3bb0c5604c29&#125;</code></p>
<h1 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h1><p>标题提示需要动调，不过还是先拖到IDA看看。看到一堆回调，这里就不放了。</p>
<p>那我们先<code>Shift+F12</code>看看字符串。</p>
<img src="/posts/moectf-2024-reverse/dynamic.png" class="" title="dynamic">
<p>咱跳过去看看引用。</p>
<img src="/posts/moectf-2024-reverse/dynamic2.png" class="" title="dynamic2">
<p>估计这块就是真正的主函数了，再跳到<code>sub_140011DC0</code>这儿。</p>
<img src="/posts/moectf-2024-reverse/dynamic3.png" class="" title="dynamic3">
<p>推测字节数组<code>v5</code>就是加密后的flag。根据输出提示这块应该是先用<code>sub_14001129E</code>解密了<code>v5</code>，然后又调用它进行加密。密钥<code>v6</code>还藏了个小彩蛋。</p>
<p>然后x64dbg在第二次加密前下个断点即可。</p>
<img src="/posts/moectf-2024-reverse/dynamic4.png" class="" title="dynamic4">
<p>在“符号”这儿拿到程序的基址，到IDA里rebase一下（编辑-&gt;段-&gt;重新设置基址）。</p>
<img src="/posts/moectf-2024-reverse/dynamic5.png" class="" title="dynamic5">
<p>然后在<code>0x7FF695761EEB</code>下断点，拿到flag了！</p>
<img src="/posts/moectf-2024-reverse/dynamic6.png" class="" title="dynamic6">
<p><code>moectf&#123;18d4c944-947c-4808-9536-c7d34d6b3827&#125;</code></p>
<h1 id="upx-revenge"><a href="#upx-revenge" class="headerlink" title="upx-revenge"></a>upx-revenge</h1><p>还是先<code>upx -d</code>，发现报错，不然咋叫revenge呢！</p>
<img src="/posts/moectf-2024-reverse/upx-revenge.png" class="" title="upx-revenge">
<p>估摸着是修改了特征码或者别的啥，拖到010editor看看。</p>
<img src="/posts/moectf-2024-reverse/upx-revenge2.png" class="" title="upx-revenge2">
<p>upx区段名被修改了。直接把<code>vmp0</code>，<code>vmp1</code>改回<code>UPX0</code>，<code>UPX1</code>看看成不成。成了。</p>
<img src="/posts/moectf-2024-reverse/upx-revenge3.png" class="" title="upx-revenge3">
<p>拖IDA里又直接告诉flag了。</p>
<img src="/posts/moectf-2024-reverse/upx-revenge4.png" class="" title="upx-revenge4">
<p><code>moectf&#123;554ea35c-a1bb-4d8f-a323-bd697564bf27&#125;</code></p>
<h1 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h1><p>拖到IDA看看。</p>
<img src="/posts/moectf-2024-reverse/TEA.png" class="" title="TEA">
<p>程序先让咱输入16进制的<code>x,y,z</code>。估计是保存到<code>v9,v10,v11</code>里了。那么它们分别谁是谁呢？</p>
<p>看一下汇编。可以看到<code>lea rdx, [rsp+48h+...]</code>的片段。这实际上就是<code>lea rdx, [rbp+...]</code>。</p>
<p>Windows x64传参顺序为<code>rcx,rdx,r8,r9,...</code>，这意味着三次调用的第二个参数分别是指向<code>v10,v11,v9</code>的指针，接下来的<code>v4</code>和<code>v5</code>即<code>xxxxxxxx</code>和<code>yyyyzzzz</code>。</p>
<p>（当然完全可以动调或者靠猜啥的也行）</p>
<img src="/posts/moectf-2024-reverse/TEA2.png" class="" title="TEA2">
<p>接下来就是一个对<code>[v4,v5]</code>的tea加密了，密钥是<code>base64xorteaxtea</code>。<code>-0x61C88647</code>和<code>+0x9E3779B9</code>效果是一样的。这是一个原封不动的tea。</p>
<img src="/posts/moectf-2024-reverse/TEA3.png" class="" title="TEA3">
<p>假如这就是一个全新但可逆的由cfbb本人设计的算法，我们该怎么解密？</p>
<p>我们就从第32次循环开始倒推。这时$v_3=32\cdot delta$，$v_5$被加后的值只依赖于手头已有的$v_3$和$v_4$的末值，那么用$v_5$减去加上的值就得到了这一轮加密之前的$v_5$，类似地可以得到$v_4$。如此循环就能得到$v_4,v_5$的初值。这种加解密过程极为相似的分组密码结构被称为<strong>Feistel结构</strong>。那么我们可以编写如下解密算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v3 = <span class="number">-32</span> * <span class="number">1640531527</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v4 = <span class="number">676078132</span>, v5 = <span class="number">957400408</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        v5 -= (v4 + v3) ^ (<span class="number">16</span> * v4 + <span class="number">1634038898</span>) ^ ((v4 &gt;&gt; <span class="number">5</span>) + <span class="number">1634038904</span>);</span><br><span class="line">        v4 -= (v5 + v3) ^ (<span class="number">16</span> * v5 + <span class="number">1702060386</span>) ^ ((v5 &gt;&gt; <span class="number">5</span>) + <span class="number">1870148662</span>);</span><br><span class="line">        v3 += <span class="number">1640531527</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;moectf&#123;%8x-%4x-%4x-9c42-caf30620caaf&#125;&quot;</span>, v4, v5 &gt;&gt; <span class="number">16</span>, v5 &amp; <span class="number">0xffff</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// moectf&#123;836153a5-8e00-49bd-9c42-caf30620caaf&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="xtea"><a href="#xtea" class="headerlink" title="xtea"></a>xtea</h1><p>拖到IDA老样子看字符串跳过去。</p>
<img src="/posts/moectf-2024-reverse/xtea.png" class="" title="xtea">
<p><code>0x140022000</code>处存着加密后的flag。仿照我们上一题TEA的流程，我把<code>sub_14001119F</code>改成解密函数，把这里整个流程倒过来执行一遍（目的和源也交换）不就解密好了？进去看看。</p>
<img src="/posts/moectf-2024-reverse/xtea2.png" class="" title="xtea2">
<p>这其实就是xtea算法，不过这里$delta$换成了<code>0xCCFFBBBB</code>（）。就算你完全不知道，解密流程就和TEA一样把加密过程倒过来就好了！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Str[<span class="number">48</span>] = &#123;</span><br><span class="line">    <span class="number">0xA3</span>, <span class="number">0x69</span>, <span class="number">0x96</span>, <span class="number">0x26</span>, <span class="number">0xBD</span>, <span class="number">0x78</span>, <span class="number">0x0B</span>, <span class="number">0x3D</span>, <span class="number">0x9D</span>, <span class="number">0xA5</span>, <span class="number">0x28</span>, <span class="number">0x62</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> Src[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> v14[<span class="number">28</span>] = &#123;<span class="number">0xBD</span>, <span class="number">0x78</span>, <span class="number">0x0B</span>, <span class="number">0x3D</span>, <span class="number">0x9D</span>, <span class="number">0xA5</span>, <span class="number">0x28</span>, <span class="number">0x62</span>&#125;;</span><br><span class="line"><span class="type">int</span> v12[<span class="number">12</span>] = &#123;<span class="number">2</span>, <span class="number">0</span> ,<span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_1400148C0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1, <span class="type">unsigned</span> <span class="type">int</span> *a2,  <span class="type">unsigned</span> <span class="type">char</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v5;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v6;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v7;</span><br><span class="line">    v6 = a2[<span class="number">1</span>];</span><br><span class="line">    v5 = *a2;</span><br><span class="line">    v7 = <span class="number">-855655493</span> * a1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        v6 -= (*(<span class="type">unsigned</span> <span class="type">int</span>*)(a3 + <span class="number">4</span> * ((v7 &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>)) + v7) ^ (v5 + ((v5 &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * v5)));</span><br><span class="line">        v7 += <span class="number">855655493</span>;</span><br><span class="line">        v5 -= (*(<span class="type">unsigned</span> <span class="type">int</span>*)(a3 + <span class="number">4</span> * (v7 &amp; <span class="number">3</span>)) + v7) ^ (v6 + ((v6 &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * v6)));</span><br><span class="line">    &#125;</span><br><span class="line">    a2[<span class="number">1</span>] = v6;</span><br><span class="line">    *a2 = v5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    sub_1400148C0(<span class="number">32</span>, v14, v12);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;Str[<span class="number">4</span>], v14, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(Src, Str, <span class="number">8</span>);</span><br><span class="line">    sub_1400148C0(<span class="number">32</span>, Src, v12);</span><br><span class="line">    <span class="built_in">memcpy</span>(Str, Src, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;moectf&#123;%s&#125;&quot;</span>, Str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// moectf&#123;moectf2024!!&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="xxtea"><a href="#xxtea" class="headerlink" title="xxtea"></a>xxtea</h1><p>拖到IDA，又是熟悉的配方。<code>v9</code>是加密后的flag。</p>
<img src="/posts/moectf-2024-reverse/xxtea.png" class="" title="xxtea">
<p>点进去看是xxtea。但是这次解密算法也被包含在程序里了（<code>if</code>那儿）！我们只要把<code>v10</code>的值改成其相反数，再把这里<code>sub_14001105F</code>的第一个参数改成<code>v9</code>就能在<code>v9</code>即<code>[rbp+8]</code>拿到flag。patch一下或者动调都可以。</p>
<img src="/posts/moectf-2024-reverse/xxtea2.png" class="" title="xxtea2">
<img src="/posts/moectf-2024-reverse/xxtea3.png" class="" title="xxtea3">
<img src="/posts/moectf-2024-reverse/xxtea4.png" class="" title="xxtea4">
<p><code>moectf&#123;j9h8hg75nky6vhkslh5v5awibr4i&#125;</code></p>
<h1 id="d0tN3t"><a href="#d0tN3t" class="headerlink" title="d0tN3t"></a>d0tN3t</h1><p>题目告诉咱是.NET逆向了，拖到dnSpy（或者ILSpy）。</p>
<img src="/posts/moectf-2024-reverse/d0tN3t.png" class="" title="d0tN3t">
<p>逻辑清晰明了，直接写脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array = [...]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(((((x ^ (i * i)) % (<span class="number">1</span> &lt;&lt; <span class="number">8</span>)) ^ <span class="number">114</span>) - <span class="number">114</span>)) <span class="keyword">for</span> (i, x) <span class="keyword">in</span> <span class="built_in">enumerate</span>(array))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># moectf&#123;7ce581d2-b2ab-4ceb-9bbe-435873083db6&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="rc4"><a href="#rc4" class="headerlink" title="rc4"></a>rc4</h1><p>老样子看字符串。</p>
<img src="/posts/moectf-2024-reverse/rc4.png" class="" title="rc4">
<p>输入flag，调用<code>sub_401360</code>用<code>RC4_1s_4w3s0m3</code>对输入进行rc4加密，结果存放在<code>v14</code>所指内存中。<code>sub_404748</code>应该是<code>strlen</code>，<code>sub_401B01</code>估计是<code>malloc</code>，<code>sub_404679</code>应当是<code>memcmp</code>。最后比较<code>v14</code>和<code>v16</code>所指内存存放内容是否一致。</p>
<img src="/posts/moectf-2024-reverse/rc42.png" class="" title="rc42">
<p>而rc4是一种<strong>自逆</strong>的对称加密算法，即对于明文$m$，密钥$k$，密文$c$，有$Enc_k(Enc_k(m))=m$，也就是$Enc_k(c)=m$，将参数中的明文地址<code>v17</code>替换成密文地址<code>v16</code>就能直接在<code>v14</code>即<code>[rbp-88h]</code>处所指的内容得到flag。</p>
<img src="/posts/moectf-2024-reverse/rc43.png" class="" title="rc43">
<p><code>v16</code>在<code>[rbp-78h]</code>，那直接patch一下把上面这句换成<code>mov rsi, [rbp-78h]</code>即可（刚好4字节）。</p>
<img src="/posts/moectf-2024-reverse/rc44.png" class="" title="rc44">
<img src="/posts/moectf-2024-reverse/rc45.png" class="" title="rc45">
<p>然后pwndbg在<code>0x401540</code>处下断就可以看到flag了。</p>
<img src="/posts/moectf-2024-reverse/rc46.png" class="" title="rc46">
<p><code>moectf&#123;why_Rc4_haS_The_Rev32sabl3_pr0ceSS&#125;</code></p>
<h1 id="逆向工程进阶指北"><a href="#逆向工程进阶指北" class="headerlink" title="逆向工程进阶指北"></a>逆向工程进阶指北</h1><p>加密就这句。</p>
<p><code>*(p + i) = (*(p + i) * 0xccffbbbb + 0xdeadc0de) ^ 0xdeadbeef + 0xd3906</code></p>
<p>注意<code>+</code>的优先级高于<code>^</code>。脱掉异或和加法，最后还要脱掉乘法——怎么脱？</p>
<p>注意这都是<code>unsigned int</code>的运算，即已知$b=xa\bmod 2^{32}$。求$x$只需要求$ba^{-1}\bmod 2^{32}$，而$\mathrm{0xccffbbbb}^{-1}\bmod 2^{32}=\mathrm{0x8d61d173}$，那么最后乘<code>0x8d61d173</code>就可以得到原数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a[<span class="number">45</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b[] = &#123;<span class="number">0xb5073388</span> , <span class="number">0xf58ea46f</span> , <span class="number">0x8cd2d760</span> , <span class="number">0x7fc56cda</span> , <span class="number">0x52bc07da</span> , <span class="number">0x29054b48</span> , </span><br><span class="line"><span class="number">0x42d74750</span> , <span class="number">0x11297e95</span> , <span class="number">0x5cf2821b</span> , <span class="number">0x747970da</span> , <span class="number">0x64793c81</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *p = (<span class="type">unsigned</span> <span class="type">int</span> *)a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i)</span><br><span class="line">        *(p + i) = ((b[i] ^ (<span class="number">0xdeadbeef</span> + <span class="number">0xd3906</span>)) - <span class="number">0xdeadc0de</span>) * <span class="number">0x8d61d173</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// moectf&#123;c5f44c32-cbb9-444e-aef4-c0fa7c7a6b7a&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="moedaily"><a href="#moedaily" class="headerlink" title="moedaily"></a>moedaily</h1><p><strong>顶级好活之Excel逆向。</strong></p>
<p>先看看各单元格做了什么。显然<code>D/E14-D/E19</code>把<code>D11</code>的内容按4字节分组。</p>
<img src="/posts/moectf-2024-reverse/moedaily.png" class="" title="moedaily">
<p>可以猜测<code>F/G14-F/G19</code>是各4字节对应的无符号数，点开一看果真如此（以<code>F14</code>为例），它将每4个字符转换为对应的无符号数（小端）。</p>
<p><code>=CODE(MID(D14,1,1))+CODE(MID(D14,2,1))*256+CODE(MID(D14,3,1))*256*256+CODE(MID(D14,4,1))*256*256*256</code></p>
<p>再看一下<code>D12</code>，这里理应有判断<code>D11</code>内容是否正确的逻辑。可以看到它将<code>H/I14-H/I19</code>的内容与指定值比较来判断正确与否，那么<code>H/I14-H/I19</code>应该就是<code>F/G14-F/G19</code>加密后的结果。</p>
<p><code>=IF(LEN(D11)=48,IF(AND(AND(AND(AND(AND(AND(H14=1397140385,I14=2386659843),AND(H15=962571399,I15=3942687964)),AND(H16=3691974192,I16=863943258)),AND(H17=216887638,I17=3212824238)),AND(H18=3802077983,I18=1839161422)),AND(H19=1288683919,I19=3222915626)),&quot;恭喜你，拿到了真的FLAG&quot;,&quot;FLAG输入错了，再试试&quot;),&quot;flag长度不对&quot;)</code></p>
<p>如果修改一下输入，会发现<code>H/I14-H/I19</code>的密文中仅有对应的两个单元格会被改变，这意味着加密方式应是某种块间无关的64位分组加密，我们只要分析任意一行两个单元格的加密逻辑即可。看看<code>H14</code>和<code>I14</code>：</p>
<p><code>=s3cr3t!E54</code>和<code>=s3cr3t!F54</code></p>
<p>在<code>s3cr3t</code>中定位到<code>E54</code>：</p>
<p><code>=BITAND(E53+BITXOR(BITLSHIFT(F53,4)+C38,BITXOR(F53+D54,BITRSHIFT(F53,5)+D38)),4294967295)</code></p>
<p>即<code>E54 = (E53 + ((F53 &lt;&lt; 4) + C38) ^ ((F53 + D54) ^ ((F53 &lt;&lt; 5) + D38))) &amp; 0xFFFFFFFF</code></p>
<p>看到上面这个应该就很眼熟了，这不就是TEA加密么？接着看<code>F54</code>：</p>
<p><code>=BITAND(F53+BITXOR(BITLSHIFT(E54,4)+E38,BITXOR(E54+D54,BITRSHIFT(E54,5)+F38)),4294967295)</code></p>
<p>即<code>F54 = (F53 + ((E54 &lt;&lt; 4) + E38) ^ ((E54 + D54) ^ ((E54 &lt;&lt; 5) + F38))) &amp; 0xFFFFFFFF</code></p>
<p>检查<code>D54</code>可以看到<code>D54 = 114514 + D53</code>。推测<code>key[] = &#123;C38, D38, E38, F38&#125;</code>且<code>delta = 114514</code>。</p>
<p>往上看32轮看到<code>A38</code>和<code>B38</code>，可以看到它们来自<code>E18</code>和<code>F18</code>，而上面是用同样的<code>key</code>和<code>delta</code>对<code>A2</code>和<code>B2</code>进行加密，而它们来自<code>Sheet1</code>的<code>F14</code>和<code>G14</code>。</p>
<p>由此可以推测进行了两次TEA加密，编写如下解密脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enc = [[<span class="number">1397140385</span>, <span class="number">2386659843</span>], [<span class="number">962571399</span>, <span class="number">3942687964</span>], [<span class="number">3691974192</span>, <span class="number">863943258</span>], [<span class="number">216887638</span>, <span class="number">3212824238</span>], [<span class="number">3802077983</span>, <span class="number">1839161422</span>], [<span class="number">1288683919</span>, <span class="number">3222915626</span>]]</span><br><span class="line">delta = <span class="number">114514</span></span><br><span class="line">keys = [[<span class="number">114514</span>, <span class="number">1919810</span>], [<span class="number">415144</span>, <span class="number">19883</span>]]</span><br><span class="line">flag = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> block <span class="keyword">in</span> enc:</span><br><span class="line">    a0, a1 = block</span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            key = keys[(i + <span class="number">1</span>) % <span class="number">2</span>]</span><br><span class="line">            a0, a1 = (a1 - (((a0 &lt;&lt; <span class="number">4</span>) + key[<span class="number">0</span>]) ^ (a0 + delta * ((i + <span class="number">1</span>) // <span class="number">2</span>)) ^ ((a0 &gt;&gt; <span class="number">5</span>) + key[<span class="number">1</span>]))) % (<span class="number">1</span> &lt;&lt; <span class="number">32</span>), a0</span><br><span class="line">    flag += a0.to_bytes(<span class="number">4</span>, <span class="string">&#x27;little&#x27;</span>) + a1.to_bytes(<span class="number">4</span>, <span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># moectf&#123;3xC3l_1S_n0t_just_f0r_d41ly_w0rk_bu7_R3V&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="moejvav"><a href="#moejvav" class="headerlink" title="moejvav"></a>moejvav</h1><p>java逆向，拖到jadx里康康。一开始把输入字符的ASCII值异或202再加32来加密。</p>
<img src="/posts/moectf-2024-reverse/moejvav.png" class="" title="moejvav">
<p>然后是一段仿虚拟机的代码，从<code>vmInsn</code>数组中取指取操作数并执行相应操作。可以看到这个<code>try-catch</code>块实际上和<code>switch insn</code>差不多。需要注意<code>insn</code>取3, 4, 5时（即<code>e4, e5, e6</code>对应的<code>catch</code>块）操作可能是不可逆的，不过实际执行时没有用到这些“指令”。</p>
<img src="/posts/moectf-2024-reverse/moejvav2.png" class="" title="moejvav2">
<p>从上边可以看到<code>insn</code>取0时会从<code>array</code>取出一个值存到<code>store</code>，取6时会比较<code>store</code>与操作数是否相等，从而此时的操作数应为输入第二次加密后的值。</p>
<p>那么我们可以顺序执行这些“指令”，每当遇到操作6时就把操作数存到<code>store</code>，并把上一个操作0至此的所有指令全部倒序执行一遍（当然操作2要替换成减），此后<code>((store - 32) ^ 202) % 256</code>就是flag中一个字符的ASCII值。从而可以编写如下脚本拿到flag：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vmInsn = [...]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">310</span>:</span><br><span class="line">    insn = vmInsn[i]</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (insn == <span class="number">114514</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> insn == <span class="number">0</span>:</span><br><span class="line">        ops = [(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">    <span class="keyword">elif</span> insn != <span class="number">6</span>:</span><br><span class="line">        ops.append((insn, vmInsn[i]))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> insn == <span class="number">6</span>:</span><br><span class="line">        store = vmInsn[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ops) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            op, num = ops[j]</span><br><span class="line">            <span class="keyword">if</span> op == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> op == <span class="number">1</span>:</span><br><span class="line">                store ^= num</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="number">2</span>:</span><br><span class="line">                store -= num</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="number">3</span> <span class="keyword">or</span> op == <span class="number">4</span> <span class="keyword">or</span> op == <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Irreversible&#x27;</span>)</span><br><span class="line">        flag += <span class="built_in">chr</span>(((store - <span class="number">32</span>) ^ <span class="number">202</span>) % (<span class="number">1</span> &lt;&lt; <span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># moectf&#123;jvav_eXcEpt10n_h4ndl3r_1s_s0_c00o0o1&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="sm4"><a href="#sm4" class="headerlink" title="sm4"></a>sm4</h1><p>用<code>key</code>对输入的48字节进行加密（sm4，不过不重要，因为程序包含了解密函数）。</p>
<p>但是需要注意<code>Data_plain</code>的长度只有48字节，这样<code>key</code>的第一个字节会被覆盖为<code>0x00</code>。</p>
<img src="/posts/moectf-2024-reverse/sm42.png" class="" title="sm42">
<img src="/posts/moectf-2024-reverse/sm4.png" class="" title="sm4">
<p>下面调用<code>decode_fun</code>又对<code>encode_Result</code>解密并将结果存放在<code>decode_Result</code>，可以直接把<code>encode_Result</code>替换成密文<code>enc</code>即<code>[rbp-60h]</code>，这样就能拿到flag。</p>
<img src="/posts/moectf-2024-reverse/sm43.png" class="" title="sm43">
<p>给它们都patch掉！顺便下面那个<code>printf</code>也改一下让它直接输出flag。</p>
<img src="/posts/moectf-2024-reverse/sm44.png" class="" title="sm44">
<img src="/posts/moectf-2024-reverse/sm45.png" class="" title="sm45">
<img src="/posts/moectf-2024-reverse/sm46.png" class="" title="sm46">
<p>然后运行一下就有flag了：</p>
<img src="/posts/moectf-2024-reverse/sm47.png" class="" title="sm47">
<p><code>moectf&#123;Congratulations_you_are_an_SM4_master!!!&#125;</code></p>
<h1 id="ezMAZE"><a href="#ezMAZE" class="headerlink" title="ezMAZE"></a>ezMAZE</h1><p>拖DIE，有upx。</p>
<img src="/posts/moectf-2024-reverse/ezMaze.png" class="" title="ezMaze">
<p>脱掉upx扔IDA，一个迷宫。起点(2, 2)，终点(75, 55)。</p>
<img src="/posts/moectf-2024-reverse/ezMaze2.png" class="" title="ezMaze2">
<p>地图大小80*56，<code>sub_140001190</code>应该是用来判断下一个位置是否有效的。</p>
<img src="/posts/moectf-2024-reverse/ezMaze3.png" class="" title="ezMaze3">
<p><code>sub_140001190</code>的逻辑：地图上的的点是<code>byte_140005000</code>数组中的比特位。检查(x, y)对应比特位，为1不能走；为0能走并把该位标记为1之后不能再走。</p>
<img src="/posts/moectf-2024-reverse/ezMaze4.png" class="" title="ezMaze4">
<p>然后把这个逻辑抄过来，再写个BFS跑出最短路径的走法，输入就能拿到flag（这里下标稍微改了下）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">maze</span>):</span><br><span class="line">    directions = [(<span class="number">0</span>, -<span class="number">1</span>, <span class="string">&#x27;w&#x27;</span>), (<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;s&#x27;</span>), (-<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;d&#x27;</span>)]</span><br><span class="line">    start, end = (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">74</span>, <span class="number">54</span>)</span><br><span class="line">    q = queue.Queue()</span><br><span class="line">    vis = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">56</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">80</span>)]</span><br><span class="line">    q.put((start, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        (x, y), path = q.get()</span><br><span class="line">        <span class="keyword">if</span> (x, y) == end:</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line">        <span class="keyword">for</span> dx, dy, d <span class="keyword">in</span> directions:</span><br><span class="line">            x_, y_ = x + dx, y + dy</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x_ &lt; <span class="number">80</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= y_ &lt; <span class="number">56</span> <span class="keyword">and</span> maze[x_][y_] == <span class="number">0</span> <span class="keyword">and</span> vis[x_][y_] == <span class="number">0</span>:</span><br><span class="line">                vis[x_][y_] = <span class="number">1</span></span><br><span class="line">                q.put(((x_, y_), path + d))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Err&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">compressed = [...]</span><br><span class="line">maze = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">56</span>)] <span class="keyword">for</span> __ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">80</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">81</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">57</span>):</span><br><span class="line">        maze[i - <span class="number">1</span>][j - <span class="number">1</span>] = (compressed[<span class="number">10</span> * j - <span class="number">10</span> + (i - <span class="number">1</span>) // <span class="number">8</span>] &gt;&gt; (<span class="number">7</span> - (i - <span class="number">1</span>) % <span class="number">8</span>)) &amp; <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(solve(maze))</span><br><span class="line"><span class="comment"># sddddddddddddddddssaaaaaaaaaaaaaaassdddddddddddddddssaaaaaaaaaaaaaaassdddddddddddddddsssdsdssddddddddddddddddssaaaaaaaaaaaaaaassdddddddddddddddssaaaaaaaaaaaaaaassdddddddddddddddsssdddwdddddddddddddddwwaaaaaaaaaaaaaaawwdddddddddddddddwwaaaaaaaaaaaaaaawwdddddddddddddddwwaaaaaaaaaaaaaaaawwddddddddddddddddwwwwaaaaaaaaaaaaaaawwdddddddddddddddwwaaaaaaaaaaaaaaawwdddddddddddddddwwddddddddddddddddddssaaaaaaaaaaaaaaassdddddddddddddddssaaaaaaaaaaaaaaassdddddddddssssaaaaaaaaaassdddddddssaaaaaassddddddddddddssaaaaaaaaaaaassdddddddddddsssssaaaaaaaaaaaaaassaaaaaaaaaaaaaaassdddddddddddddddssaaaaaaaaaaaaaaassdddddddddddddddssssaaaaaaaaaaaaaaaassddddddddddddddddssaaaaaaaaaaaaaaassdddddddddddddddssaaaaaaaaaaaaaaassaaaaaaaaaaaaaaaaaawwdddddddddddddddwwaaaaaaaaaaaaaaawwdddddddddddddddwwaaaaaaaaaaaaaaaawwawawwwaaaaaaaaaaaaaawwddddddddddddddwwaaaaaaaaaaaaaawwddddddddddddddwwaaaaaaaaaaaaaaaasssssssssssssssssssssssssddddddddddddddddddddddddddddddddddwddddddddddddddddddwdddwwwdddddddddddddddwwaaaaaaaaaaaaaaawwddddddwwaaaaaaawwddddddddddddddssdddwwwawwwaaaaaaaaaaaaaaawwdddddddddddddddwwaaaaaaaaaaaaaaawwdddddddddddddddwwwwwwwwwwwwwwwwwwwwwdddssssssssssssssssssssssssssssssssssssssssssss</span></span><br></pre></td></tr></table></figure>
<img src="/posts/moectf-2024-reverse/ezMaze5.png" class="" title="ezMaze5">
<p><code>moectf&#123;the_18446744024826406994_amazing_maze!!&#125;</code></p>
<h1 id="Just-Run-It"><a href="#Just-Run-It" class="headerlink" title="Just-Run-It"></a>Just-Run-It</h1><p>只要成功运行这四个程序就能拿到flag。可是事情也没有太简单。</p>
<p><code>0x0.exe</code>能直接在win64运行，这没啥好说的。</p>
<img src="/posts/moectf-2024-reverse/Just-Run-It.png" class="" title="Just-Run-It">
<p>在wsl试图运行<code>0x1.elf</code>，依赖有点问题。</p>
<img src="/posts/moectf-2024-reverse/Just-Run-It2.png" class="" title="Just-Run-It2">
<p>不过还好只是加了个upx，脱壳之后可以拿到。</p>
<img src="/posts/moectf-2024-reverse/Just-Run-It3.png" class="" title="Just-Run-It3">
<p><code>0x2.apk</code>需要在Android 14上运行。</p>
<img src="/posts/moectf-2024-reverse/Just-Run-It4.png" class="" title="Just-Run-It4">
<p>而我没有实体机，Android Studio也因为各种原因无法启动ARM架构的模拟器，反编译工具也无法反编译程序的关键部分——</p>
<p>然后我就找了个<a target="_blank" rel="noopener" href="https://appetize.io">在线的模拟器</a>凑合了：</p>
<img src="/posts/moectf-2024-reverse/Just-Run-It5.png" class="" title="Just-Run-It5">
<p><code>0x3.riscv64.elf</code>是一个RISC-V架构下的64位Linux程序，IDA无法反编译<del>（字符串里还有”zaku~zaku~“的雌小鬼字样）</del>。</p>
<p>那么要想拿到flag，最方便的方式就是在qemu创建一个RISC-V架构的64位虚拟机并运行这个程序<del>（而不是阅读RISC-V汇编）</del>。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/orangeQWJ/p/18171574">这里</a>有一个比较方便的教程。照着做就有如下一长串命令来安装并启动虚拟机：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 -M virt -m 2048M -smp 4  -bios fw_jump.bin -kernel u-boot.bin -drive file=ubuntu-22.04.4-preinstalled-server-riscv64+unmatched.img,format=raw,<span class="keyword">if</span>=virtio -drive file=riscv_disk.img,format=raw,<span class="keyword">if</span>=virtio -netdev user,<span class="built_in">id</span>=net0,hostfwd=tcp::2222-:22 -device virtio-net-device,netdev=net0 -nographic -device virtio-rng-pci</span><br></pre></td></tr></table></figure>
<p>上面的命令中<code>hostfwd</code>参数将宿主机<code>2222</code>端口转发到客户机<code>22</code>即ssh端口，我们能通过scp将<code>0x3.riscv64.elf</code>传输给客户机：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 0x3.riscv64.elf ubuntu@localhost:~/</span><br></pre></td></tr></table></figure>
<p>然后就能拿到最后一块flag碎片了。</p>
<img src="/posts/moectf-2024-reverse/Just-Run-It7.png" class="" title="Just-Run-It7">
<p>显然前面三块碎片应该是ASCII字符串的hex，第四块是ASCII值，拼起来拿到原字符串。</p>
<p><code>bW9lY3RmezU5ZmE2MDJjLTYyNGEtNDBiNy04YTVjLWUzNWU1NzRjZjliOX0=</code></p>
<p>一眼base64，解码拿到flag。</p>
<p><code>moectf&#123;59fa602c-624a-40b7-8a5c-e35e574cf9b9&#125;</code></p>
<h1 id="SecretModule"><a href="#SecretModule" class="headerlink" title="SecretModule"></a>SecretModule</h1><p>模块刷入时会执行<code>customize.sh</code>，我们直接阅读这个脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(printf &#x27;...&#x27; | base64 -d | bunzip2 -c)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>脚本自解压并用<code>eval</code>执行，被执行的代码为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">testk</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Welcome to the Secret module!But before you begin,you need to prove your self.&quot;</span></span><br><span class="line">  (/system/bin/getevent -lc 1 2&gt;&amp;1 | /system/bin/grep VOLUME | /system/bin/grep <span class="string">&quot; DOWN&quot;</span> &gt; <span class="variable">$MODPATH</span>/events) || <span class="built_in">return</span> 1</span><br><span class="line">  <span class="built_in">return</span> 0</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">choose</span></span>() &#123;</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    /system/bin/getevent -lc 1 2&gt;&amp;1 | /system/bin/grep VOLUME | /system/bin/grep <span class="string">&quot; DOWN&quot;</span> &gt; <span class="variable">$MODPATH</span>/events</span><br><span class="line">    <span class="keyword">if</span> (`<span class="built_in">cat</span> <span class="variable">$MODPATH</span>/events 2&gt;/dev/null | /system/bin/grep VOLUME &gt;/dev/null`); <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">if</span> (`<span class="built_in">cat</span> <span class="variable">$MODPATH</span>/events 2&gt;/dev/null | /system/bin/grep VOLUMEUP &gt;/dev/null`); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;114514&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;1919810&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> testk; <span class="keyword">then</span></span><br><span class="line">  ui_print <span class="string">&quot;Great! Now enter the secret.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ui_print <span class="string">&quot;Legacy Device. Use a newer device to do this challenge&quot;</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">concatenated=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 1 2 3 4 5 6 7</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  result=$(choose)</span><br><span class="line">  concatenated=<span class="string">&quot;<span class="variable">$&#123;concatenated&#125;</span><span class="variable">$&#123;result&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">input_str=$(<span class="built_in">echo</span> -n <span class="variable">$concatenated</span> | <span class="built_in">md5sum</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">sec=<span class="string">&quot;77a58d62b2c0870132bfe8e8ea3ad7f1&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$input_str</span> = <span class="variable">$sec</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&#x27;You are right!Flag is&#x27;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;moectf&#123;<span class="variable">$concatenated</span>&#125;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;Wrong. Try again.&#x27;</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>脚本监听音量上下键按键事件，按上给字符串<code>$concatenated</code>拼接<code>114514</code>，按下拼接<code>1919810</code>，重复7次并检查<code>$concatenated</code>的MD5值是否为<code>$sec</code>，最终flag为<code>moectf&#123;$concatenated&#125;</code>，从而可以写如下脚本爆破：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> MD5</span><br><span class="line">s1 = <span class="string">&#x27;114514&#x27;</span></span><br><span class="line">s2 = <span class="string">&#x27;1919810&#x27;</span></span><br><span class="line">sec = <span class="string">&#x27;77a58d62b2c0870132bfe8e8ea3ad7f1&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; <span class="number">7</span>):</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        <span class="keyword">if</span> i &amp; (<span class="number">1</span> &lt;&lt; j):</span><br><span class="line">            s += s1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s += s2</span><br><span class="line">    digest = MD5.new()</span><br><span class="line">    digest.update(s.encode())</span><br><span class="line">    <span class="keyword">if</span> digest.hexdigest() == sec:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;moectf&#123;&#x27;</span> + s + <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># moectf&#123;114514114514191981011451411451419198101919810&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="Cython-Strike-Bomb-Defusion"><a href="#Cython-Strike-Bomb-Defusion" class="headerlink" title="Cython-Strike: Bomb Defusion"></a>Cython-Strike: Bomb Defusion</h1><p>把<code>.pyd</code>放DIE里看看，一个开了Themida保护的DLL库。</p>
<img src="/posts/moectf-2024-reverse/cython-strike.png" class="" title="cython-strike">
<p>拖到IDA，发现<strong><code>.data</code>段没有被保护</strong>：</p>
<img src="/posts/moectf-2024-reverse/cython-strike2.png" class="" title="cython-strike2">
<p>装好模块之后用<code>dir</code>看一下模块提供的类和方法。</p>
<img src="/posts/moectf-2024-reverse/cython-strike3.png" class="" title="cython-strike3">
<p>尝试使用一下这些方法。</p>
<img src="/posts/moectf-2024-reverse/cython-strike4.png" class="" title="cython-strike4">
<p>之后使用<code>read_memory</code>方法发现读出来的内容就是之前IDA里看到的那段。</p>
<p><code>...#de.i.e MAX_... 0xffffff...unsign.d int ma..;...int p.ant_b..b(unsigned int input)&#123;if .input &lt;= MAX_...) &#123;ma.. = input;r..urn 0;&#125; e.se.&#123;...ret..n -1;&#125; &#125;...void expl.de_b.m...oid).&#123;...void def..e_..mb(v.id)&#123;...&#125;...check_p..d(uns.gned.int in.u.).&#123;if.(input.&gt; MAX_...).&#123;...explode_b..b();...&#125;...if.((in..t ^ ma.. == 114) &amp;&amp; (input &lt;&lt; (ma.. % 5) + 1 == 60578736)).&#123;defuse_b..b();r..urn..&#125;...explode_b..b();...retu..;...&#125;............................................................................................</code></p>
<p>这应该差不多是<code>enter_pwd</code>里的逻辑，<code>b.enter_pwd(60578736 &gt;&gt; (b.mask % 5) + 1)</code>就能拿到flag了。至于<code>in..t ^ ma.. == 114</code>这个判断，应该是有另外一个名字差不多的变量蒙混过关的。</p>
<p><code>moectf&#123;CoUnter_TerR0rists_w1n&#125;</code></p>
<h1 id="SMCProMax"><a href="#SMCProMax" class="headerlink" title="SMCProMax"></a>SMCProMax</h1><p>上来看到这个<code>sub_401000</code>。首先调用<code>VirtualProtect</code>修改相应页面内存保护选项为读写执行，然后给<code>0x40105E</code>到<code>0x401427</code>的所有字节全部异或<code>0x90</code>，还原代码并执行。</p>
<img src="/posts/moectf-2024-reverse/SMCProMax.png" class="" title="SMCProMax">
<p>那直接用IDA给它patch回去。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ida_bytes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40105E</span>, <span class="number">0x401428</span>):</span><br><span class="line">    patch_byte(i, get_wide_byte(i) ^ <span class="number">0x90</span>)</span><br></pre></td></tr></table></figure>
<p>往后看一看可以发现这里才应该是<code>sub_401000</code>结束的地方。</p>
<img src="/posts/moectf-2024-reverse/SMCProMax2.png" class="" title="SMCProMax2">
<p>再修改一下函数结束地址和函数类型让IDA正常反编译。</p>
<img src="/posts/moectf-2024-reverse/SMCProMax3.png" class="" title="SMCProMax3">
<img src="/posts/moectf-2024-reverse/SMCProMax4.png" class="" title="SMCProMax4">
<p>然后就能正常阅读了。虽然不知道为什么，我设置了合适的参数，但它还是<code>buffer</code>给标成<code>retaddr[1]</code>了<del>（让我强迫症看着有点不爽）</del>。</p>
<p>开头先给<code>buffer[23]</code>异或<code>0x12</code>，然后对<code>buffer</code>中40字节每4字节以相同逻辑加密，并与给定密文比较。</p>
<img src="/posts/moectf-2024-reverse/SMCProMax5.png" class="" title="SMCProMax5">
<img src="/posts/moectf-2024-reverse/SMCProMax6.png" class="" title="SMCProMax6">
<p>这个<code>if-else</code>看起来似乎有些难搞，但稍微仔细一点会发现根据<code>v25 &amp; 1</code>就能判断它前一轮加密进入了哪个分支。</p>
<p>上轮进入<code>else</code>分支时必有<code>v25 &lt; 0</code>即<code>v25 &amp; (1 &lt;&lt; 31) != 0</code>，而乘2即左移一位时会抹掉最高位，因此还原时需要恢复；若是上轮进入<code>if</code>分支，则直接右移一位即可。那么我们就能编写如下解密程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> enc[<span class="number">10</span>] = &#123;<span class="number">2053092702</span>, <span class="number">-490481854</span>, <span class="number">-1704322843</span>, <span class="number">-1418679088</span>, <span class="number">86802781</span>, <span class="number">987171458</span>, <span class="number">965631658</span>, <span class="number">264545711</span>, <span class="number">-1342106783</span>, <span class="number">-825370173</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">        x = (x &amp; <span class="number">1</span>) ? ((<span class="number">1</span> &lt;&lt; <span class="number">31</span>) + ((x ^ <span class="number">0xC4F3B4B3</span>) &gt;&gt; <span class="number">1</span>)) : (x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        enc[i] = decrypt(enc[i]);</span><br><span class="line">    *((<span class="type">unsigned</span> <span class="type">char</span> *)enc + <span class="number">23</span>) ^= <span class="number">0x12</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span> *)enc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// moectf&#123;y0u_mu5t_know_vvZAt_1s__SMC__n0w&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="xor-大嘘"><a href="#xor-大嘘" class="headerlink" title="xor(大嘘)"></a>xor(大嘘)</h1><p>扔进来一看似乎人畜无害，简单的加密和比较。</p>
<img src="/posts/moectf-2024-reverse/xor_daxu.png" class="" title="xor_daxu">
<p>看看<code>sub_401100</code>，似乎也很简单，就异或一下嘛。</p>
<img src="/posts/moectf-2024-reverse/xor_daxu2.png" class="" title="xor_daxu2">
<p>不过拿到了假flag：</p>
<p><code>This_1s_a_f4k3_flag_plzTry_ag4in</code></p>
<p>怎么回事呢，来直接看看汇编。</p>
<img src="/posts/moectf-2024-reverse/xor_daxu3.png" class="" title="xor_daxu3">
<p><code>call $+5</code>其实就是<code>push 0x401159</code>（也不一定，基址可能有变化，总之是下一条指令的地址）并执行下一条指令。</p>
<p>然后<code>add [esp], 6</code>让刚才<code>push</code>的地址刚好跳过<code>add</code>和<code>retn</code>占用的这6字节。</p>
<p>从而最后<code>retn</code>会让<code>eip</code>指向<code>retn</code>的下一条指令。</p>
<p>而IDA遇到<code>retn</code>就会认定这是一个函数结束的位置，反编译就会被这种junk code干扰。直接把它们都<code>nop</code>掉，再修改一下函数结束地址就好了。</p>
<img src="/posts/moectf-2024-reverse/xor_daxu4.png" class="" title="xor_daxu4">
<img src="/posts/moectf-2024-reverse/xor_daxu5.png" class="" title="xor_daxu5">
<p>可以看到除了开头那轮异或还进行了一次TEA和一轮异或。那么可以编写如下程序解密：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a1[<span class="number">33</span>] = &#123;<span class="number">0x3C</span>, <span class="number">0x0D</span>, <span class="number">0x05</span>, <span class="number">0x1F</span>, <span class="number">0x30</span>, <span class="number">0x6E</span>, <span class="number">0x1E</span>, <span class="number">0x30</span>, <span class="number">0x04</span>, <span class="number">0x3C</span>, <span class="number">0x12</span>, <span class="number">0x52</span>, <span class="number">0x59</span>, <span class="number">0x03</span>, <span class="number">0x6D</span>, <span class="number">0x52</span>, <span class="number">0x04</span>, <span class="number">0x04</span>, <span class="number">0x0B</span>, <span class="number">0x33</span>, <span class="number">0x1F</span>, <span class="number">0x33</span>, <span class="number">0x17</span>, <span class="number">0x3B</span>, <span class="number">0x17</span>, <span class="number">0x1A</span>, <span class="number">0x2B</span>, <span class="number">0x07</span>, <span class="number">0x55</span>, <span class="number">0x04</span>, <span class="number">0x5B</span>, <span class="number">0x5A</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dword_404078[] = &#123;<span class="number">0x6C6C6568</span>, <span class="number">0x6F6D5F6F</span>, <span class="number">0x66746365</span>, <span class="number">0x34323032</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> v8[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> v2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v4, v5;</span><br><span class="line"></span><br><span class="line">    v8[...] = ...;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">        a1[i] ^= v8[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        v4 = *(<span class="type">unsigned</span> <span class="type">int</span>*)(a1 + <span class="number">8</span> * i + <span class="number">4</span>);</span><br><span class="line">        v5 = *(<span class="type">unsigned</span> <span class="type">int</span>*)(a1 + <span class="number">8</span> * i);        </span><br><span class="line">        v2 = <span class="number">-1640531527</span> * <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j) &#123;</span><br><span class="line">            v4 -= (dword_404078[<span class="number">3</span>] + (v5 &gt;&gt; <span class="number">5</span>)) ^ (v2 + v5) ^ (dword_404078[<span class="number">2</span>] + <span class="number">16</span> * v5);</span><br><span class="line">            v5 -= (dword_404078[<span class="number">1</span>] + (v4 &gt;&gt; <span class="number">5</span>)) ^ (v2 + v4) ^ (dword_404078[<span class="number">0</span>] + <span class="number">16</span> * v4);</span><br><span class="line">            v2 += <span class="number">1640531527</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *(<span class="type">unsigned</span> <span class="type">int</span>*)(a1 + <span class="number">8</span> * i + <span class="number">4</span>) = v4;</span><br><span class="line">        *(<span class="type">unsigned</span> <span class="type">int</span>*)(a1 + <span class="number">8</span> * i) = v5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">        a1[i] ^= *((<span class="type">unsigned</span> <span class="type">char</span>*)dword_404078 + i % <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// moectf&#123;how_an_easy_junk_and_tea&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="babe-z3"><a href="#babe-z3" class="headerlink" title="babe-z3"></a>babe-z3</h1><p>加了upx，脱掉扔IDA，可以看到输入按8字节分组放在<code>s</code>，<code>v11</code>，<code>v12</code>，<code>v13</code>中。</p>
<img src="/posts/moectf-2024-reverse/babe-z3.png" class="" title="babe-z3">
<p>然后判断一系列条件是否成立，注意最后一个<code>if</code>表明第一个条件需要不成立。</p>
<img src="/posts/moectf-2024-reverse/babe-z32.png" class="" title="babe-z32">
<p>然后把前七个约束添加到z3里就能求解了。这里<code>s</code>，<code>v11</code>，<code>v12</code>，<code>v13</code>都是64位位向量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> solver.model()[x].as_long().to_bytes(<span class="number">8</span>, <span class="string">&#x27;little&#x27;</span>).decode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">solver = Solver()</span><br><span class="line">s = BitVec(<span class="string">&#x27;s&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">v11 = BitVec(<span class="string">&#x27;v11&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">v12 = BitVec(<span class="string">&#x27;v12&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">v13 = BitVec(<span class="string">&#x27;v13&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">solver.add((v12 &amp; v13 ^ (v11 | ~(v13 + v11)) &amp; s &amp; v12) != <span class="number">0xD81AC01FBBA91837</span>)</span><br><span class="line">solver.add((v11 ^ (v12 &amp; (s + v12) | v13 &amp; ~(v12 &amp; s) | v11 &amp; (v11 + v13) &amp; ~s)) == <span class="number">0x7071001344417B54</span>)</span><br><span class="line">solver.add(((v12 - v13) ^ (s - v11)) == <span class="number">0x3FE01013130FFD3</span>)</span><br><span class="line">solver.add((s + v12 - v13 + v11) * (v13 + s + v11 - v12) == <span class="number">0x1989A41A9049C5C9</span>)</span><br><span class="line">solver.add((v12 + v11 + s + v13) % <span class="number">0x1BF52</span> == <span class="number">21761</span>)</span><br><span class="line">solver.add(v13 * v12 * v11 * s % <span class="number">0x1D4B42</span> == <span class="number">827118</span>)</span><br><span class="line">solver.add((v12 &amp; s &amp; v13 | (~(v11 | s) | v11 &amp; v12) &amp; v11 &amp; s) == <span class="number">0x2024243035302131</span>)</span><br><span class="line"><span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;moectf&#123;&#x27;</span> + f(s) + f(v11) + f(v12) + f(v13) + <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line"><span class="comment"># moectf&#123;9c0525dcbadf4cbd9715067159453e74&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="moeprotector"><a href="#moeprotector" class="headerlink" title="moeprotector"></a>moeprotector</h1><h2 id="静态调试"><a href="#静态调试" class="headerlink" title="静态调试"></a>静态调试</h2><p>脱掉upx，扔到IDA，看起来没什么有用的代码。</p>
<img src="/posts/moectf-2024-reverse/moeprotector.png" class="" title="moeprotector">
<p>但是在汇编里可以看到，这段代码被包裹在一个<code>__try</code>块中（这只是非常粗浅的理解），可以发现<code>__except</code>包裹的语句才是真正需要执行的部分。这段代码在输入0时抛出除0异常进而执行<code>__except</code>部分。</p>
<img src="/posts/moectf-2024-reverse/moeprotector2.png" class="" title="moeprotector2">
<p><code>__except</code>里也套了<code>__try...__except</code>。</p>
<img src="/posts/moectf-2024-reverse/moeprotector3.png" class="" title="moeprotector3">
<p><code>__try</code>中这一部分检查输入长度是否为<code>0x39</code>，不是就打印<code>nonono, length is wrong...</code>。不论是不是都抛出异常跳到<code>loc_4017FD</code>。</p>
<img src="/posts/moectf-2024-reverse/moeprotector4.png" class="" title="moeprotector4">
<p>而<code>loc_4017FD</code>中调用了<code>sub_4010E0</code>，这个函数我会在之后分析。</p>
<img src="/posts/moectf-2024-reverse/moeprotector5.png" class="" title="moeprotector5">
<p>让我们看看<code>loc_401830</code>做了什么。</p>
<p>Win32下FS段寄存器（Win64下是GS）指向<strong>TEB</strong> (<strong>Thread Environment Block</strong>) 结构体，它储存关于当前线程的各种信息。</p>
<p>该结构体<code>0x30</code>字节偏移处是线程所在进程的<strong>PEB</strong> (<strong>Process Environment Block</strong>) 结构体所在地址，这个结构体储存关于当前进程的各种信息。</p>
<p>而PEB的2字节偏移处是<code>BeingDebugged</code>，调试器附加时该项非0，因此可以测试它来进行基础的反调试。</p>
<img src="/posts/moectf-2024-reverse/moeprotector6.png" class="" title="moeprotector6">
<p>程序继续检测调试器，这次把<code>ProcessParameters</code>拿出来用了。它是PEB的<code>0x10</code>字节偏移处一个<code>_RTL_USER_PROCESS_PARAMETERS</code> 结构体的地址。这个结构体储存进程创建相关的参数。</p>
<p>然后检测该结构体8字节偏移处的<code>Flags</code>的第14位是否为1。</p>
<p>我找遍互联网也没找到这是干什么用的，但是查到ScyllaHide反反调试时有把该位置1的操作。我猜测该位记录进程是否使用默认的PEB<del>（GPT这样说，不过听起来有一定合理性）</del>。</p>
<img src="/posts/moectf-2024-reverse/moeprotector7.png" class="" title="moeprotector6">
<p>这次用到了PEB的<code>0x18</code>字节偏移处的<code>ProcessHeap</code>。它是Windows进程（默认的）堆，堆头有一些信息可以用来反调试。</p>
<p>这里测试堆<code>0x0C</code>字节偏移处的<code>Flags</code>是否为<code>HEAP_GROWABLE(2)</code>来反调试，它是正常情况下的值。</p>
<img src="/posts/moectf-2024-reverse/moeprotector8.png" class="" title="moeprotector8">
<p>然后就遇到了一堆向量化指令，初看一脸懵逼。</p>
<img src="/posts/moectf-2024-reverse/moeprotector9.png" class="" title="moeprotector9">
<img src="/posts/moectf-2024-reverse/moeprotector10.png" class="" title="moeprotector10">
<p>但是由于输入长度刚好多1字节，对未被编译器优化的最后1字节的处理给了我们充分的提示。</p>
<img src="/posts/moectf-2024-reverse/moeprotector11.png" class="" title="moeprotector11">
<p>上面这段汇编基本上在做的是<code>byte_40543C[0x38] = (byte_40543C[0x38] ^ (0x38 + 0x15)) + 0x14</code>。</p>
<p>有理由猜想上面的向量化指令被优化前就是<code>byte_40543C[i] = (byte_40543C[i] ^ (i + 0x15)) + 0x14</code>。粗略阅读一下上面的汇编会发现的确如此<del>（不过要直接理解真有点麻烦的）</del>。</p>
<p>后面还有两段几乎一样的代码，只不过<code>0x15</code>被换成了<code>0x1A</code>和<code>0x19</code>。至于中间没有操作<code>byte_40543C</code>的部分直接忽略就可以了。</p>
<p>最后程序比较<code>byte_403658</code>与<code>byte_40543C</code>处的<code>0x39</code>字节内容是否相同。</p>
<img src="/posts/moectf-2024-reverse/moeprotector12.png" class="" title="moeprotector12">
<p>拿这个密文解密3次就能拿到flag了，解密程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> byte_403658[] = &#123;</span><br><span class="line">    <span class="number">0xC7</span>, <span class="number">0xC4</span>, <span class="number">0xC9</span>, <span class="number">0xCE</span>, <span class="number">0xC2</span>, <span class="number">0xD1</span>, <span class="number">0x8B</span>, <span class="number">0x66</span>, <span class="number">0x6B</span>, <span class="number">0x8D</span>, <span class="number">0xB0</span>, <span class="number">0x45</span>, <span class="number">0xF9</span>, <span class="number">0x84</span>, <span class="number">0xFF</span>, <span class="number">0xB2</span>, </span><br><span class="line">    <span class="number">0x51</span>, <span class="number">0xAB</span>, <span class="number">0xB3</span>, <span class="number">0x4C</span>, <span class="number">0x33</span>, <span class="number">0xA8</span>, <span class="number">0x61</span>, <span class="number">0x0E</span>, <span class="number">0xC5</span>, <span class="number">0x3B</span>, <span class="number">0x5B</span>, <span class="number">0xF9</span>, <span class="number">0x11</span>, <span class="number">0x82</span>, <span class="number">0x8B</span>, <span class="number">0x8E</span>, </span><br><span class="line">    <span class="number">0x7A</span>, <span class="number">0x23</span>, <span class="number">0x68</span>, <span class="number">0x7A</span>, <span class="number">0x21</span>, <span class="number">0x1F</span>, <span class="number">0x87</span>, <span class="number">0x91</span>, <span class="number">0x46</span>, <span class="number">0x8D</span>, <span class="number">0x90</span>, <span class="number">0xA4</span>, <span class="number">0xA5</span>, <span class="number">0xE0</span>, <span class="number">0x35</span>, <span class="number">0xD9</span>, </span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x4E</span>, <span class="number">0x44</span>, <span class="number">0xF1</span>, <span class="number">0x37</span>, <span class="number">0xAF</span>, <span class="number">0x26</span>, <span class="number">0x3A</span>, <span class="number">0x8F</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> keys[] = &#123;<span class="number">0x19</span>, <span class="number">0x1A</span>, <span class="number">0x15</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x39</span>; ++j)</span><br><span class="line">            byte_403658[j] = (byte_403658[j] - <span class="number">0x14</span>) ^ (j + keys[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, byte_403658);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// moectf&#123;w1Nd0Ws_S3H_15_A_g0oD_m37h0d_70_h4nd13_EXCEPTI0NS&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="sub-4010E0，以及反反调试"><a href="#sub-4010E0，以及反反调试" class="headerlink" title="sub_4010E0，以及反反调试"></a>sub_4010E0，以及反反调试</h2><p>它到底做了什么？其实动调比较容易看出来，不过我尝试静调弄懂原理。</p>
<p><code>fs:30h</code>处是PEB的地址，<code>_PEB + 0Ch</code>是一个<code>_PEB_LDR_DATA</code>结构体的地址<code>Ldr</code>，该结构体主要按不同顺序维护三个双向链表，包含进程所加载的模块的信息。</p>
<p><code>_PEB_LDR_DATA + 0Ch</code>是按模块加载顺序组织的链表表头<code>InLoadOrderModuleList</code>，链表每一个节点都是一个<code>_LDR_MODULE</code>结构体，储存一个模块的信息并包含指向前后节点的指针。</p>
<p>这个链表前两个表项分别与程序自身和<code>NTDLL.DLL</code>相关，第三个与<code>KERNEL32.DLL</code>相关（这里取的就是第三个）。</p>
<p>而<code>_LDR_MODULE + 18h</code>是模块基址<code>BaseAddress</code>（前<code>0x18</code>字节是3个链表的前后节点的指针），所以这里就是取了<code>KERNEL32.DLL</code>的基址存放到<code>[ebp-20h]</code>。</p>
<p>注意<code>mov esi, ecx</code>，在调用<code>sub_4010E0</code>前有一句<code>mov ecx, offset unk_4053B8</code>。<code>esi</code>在之后被多次使用并用被来填充<code>0x4053B8</code>开始的这段内存。</p>
<img src="/posts/moectf-2024-reverse/moeprotector13.png" class="" title="moeprotector13">
<p>然后把基址也存到<code>edx</code>和<code>[ebp-8h]</code>。分析这之后的部分就需要对PE文件结构有一些了解了。</p>
<p><a target="_blank" rel="noopener" href="https://upload.wikimedia.org/wikipedia/commons/1/1b/Portable_Executable_32_bit_Structure_in_SVG_fixed.svg">32位PE文件结构图</a></p>
<p>PE文件以DOS头即<code>_IMAGE_DOS_HEADER</code>结构体开头，<code>_IMAGE_DOS_HEADER + 3Ch</code>是<code>e_lfanew</code>，它是NT头（一个<code>_IMAGE_NT_HEADERS</code>结构体）的地址（装载后只是偏移）。DOS头和NT头之间有DOS Stub，它是程序在DOS系统上所执行的内容。</p>
<p><code>_IMAGE_NT_HEADERS + 78h</code>指向可选NT头（一个<code>_IMAGE_OPTIONAL_HEADER</code>结构体）的<code>DataDirectory</code>数组的第一项。</p>
<p><code>DataDirectory</code>是一个长度为16的<code>_IMAGE_DATA_DIRECTORY</code>结构体数组，这个结构体存放PE文件各种表的偏移和大小。</p>
<p>它的第一项就是导出表（一个<code>_IMAGE_EXPORT_DIRECTORY</code>结构体）的偏移和大小。导出表存放着PE文件导出的函数名称和偏移等信息。</p>
<p>接着把<code>NumberOfFunctions</code>，<code>NumberOfNames</code>，<code>AddressOfFunctions</code>，<code>AddressOfNames</code>，<code>AddressOfNameOrdinals</code>加载到栈上。</p>
<img src="/posts/moectf-2024-reverse/moeprotector14.png" class="" title="moeprotector14">
<p>然后就是一堆反编译出来比较奇怪的代码，但还是能看出来大概什么意思。（就不放图了）</p>
<p>总之就是在<code>AddressOfNames</code>按名查找<code>GetProcAddress</code>的位置，然后在<code>AddressOfNameOrdinals</code>根据这个位置查到函数地址在<code>AddressOfFunctions</code>中的位置，最后从<code>AddressOfFunctions</code>拿到<code>GetProcAddress</code>的地址并把它存放在<code>0x4053B8 + 0Ch</code>。</p>
<p>之后调用<code>GetProcAddress(kernel32.dll基址, &quot;GetModuleHandleW&quot;)</code>并把地址存放在<code>0x4053B8 + 5Ch</code>。</p>
<img src="/posts/moectf-2024-reverse/moeprotector15.png" class="" title="moeprotector15">
<p>最后反复调用<code>GetModuleHandleW</code>和<code>GetProcAddress</code>，将<code>KERNEL32.DLL</code>，<code>KERNELBASE.DLL</code>，<code>NTDLL.DLL</code>，<code>USER32.DLL</code>中一些函数的地址存放在<code>0x4053B8</code>（这里只是静态）开始的内存区域，供以后调用。（过程这就不放了，F5能看个大概）</p>
<p>如果中间出现问题，<code>sub_4010E0</code>返回0，程序最后打印<code>nonono</code>。</p>
<p>调试器附加时，程序异常会先抛给调试器，<code>Shift+F9</code>（或者直接把异常处理者设置成被调试者）可以把异常扔回给SEH处理。</p>
<p>第一次加密前的反调试措施在静态分析部分已描述过，只要手动修改相应的值（或者ScyllaHide把PEB勾上）就能绕过。</p>
<p>在第一次加密后，程序利用之前获得的地址先后调用了<code>CreateMutexW</code>，<code>SetHandleInformation</code>，<code>NtClose</code>，<code>CloseHandle</code>。</p>
<p>前两个没啥影响，但调用<code>NtClose</code>和<code>CloseHandle</code>时，如果附加了调试器，释放无效句柄（这里分别是<code>0xDEADC0DE</code>和<code>esi</code>中的垃圾值）会抛出<code>EXCEPTION_INVALID_HANDLE</code>异常；如果未附加，它们只是返回<code>FALSE</code>。ScyllaHide勾选NtClose就能给它hook掉，或者IDA静态patch掉也ok。</p>
<p>第二次加密后，程序先后调用了<code>NtQueryInformationProcess</code>，<code>CreateFileW</code>。</p>
<p>程序调用<code>NtQueryInformationProcess(-1, 7, ebp-48h, 4, 0)</code>。<code>-1</code>指代当前进程的句柄，传入<code>ProcessDebugPort(7)</code>使函数在<code>ebp-48h</code>写入<strong>进程调试器的端口号，-1说明被调试</strong>，第四个参数是写入字节数，第五个是成功写入字节数存放的地址。想要绕过它你可以：</p>
<ol>
<li>修改<code>[ebp-48h]</code>为0。</li>
<li>静态patch。</li>
<li>ScyllaHide勾选NtQueryInformationProcess。</li>
</ol>
<p>然后调用<code>CreateFileW(&quot;\\\\.\\TitanHide&quot;, 0xC0000000, 0, 0, 3, 0, 0)</code>以<strong>独占</strong>读写方式创建<strong>已经存在的</strong>设备<code>\\.\TitanHide</code>的一个句柄。</p>
<p>通常程序利用创建调试器未关闭的设备 / 文件句柄时，函数返回-1来反调试。但是这个<code>\\.\TitanHide</code>本来就不存在，因此正常情况下才会返回-1。</p>
<p>第三次加密后调用<code>NtTerminateProcess(0, 0)</code>，第一个参数为进程句柄，为0即未指定会结束调用进程以外的所有进程，这对调试好像并没有什么影响。</p>
<p>进入<code>sub_4015C0</code>就是弹窗了，不是很重要就不分析了。</p>
<p>最后推荐一个总结了一些反调试技巧的<a target="_blank" rel="noopener" href="https://anti-debug.checkpoint.com/">网站</a>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://0rd1r3hv.github.io">Ordirehv</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://0rd1r3hv.github.io/posts/moectf-2024-reverse/">https://0rd1r3hv.github.io/posts/moectf-2024-reverse/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://0rd1r3hv.github.io" target="_blank">Ordirehv's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MoeCTF-2024/">MoeCTF 2024</a></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ordirehv</div><div class="author-info__description">Maho Shojo creeping in CS.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/0rd1r3hv" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:ord1r3hv@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97"><span class="toc-text">逆向工程入门指北</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#xor"><span class="toc-text">xor</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#upx"><span class="toc-text">upx</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dynamic"><span class="toc-text">dynamic</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#upx-revenge"><span class="toc-text">upx-revenge</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TEA"><span class="toc-text">TEA</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#xtea"><span class="toc-text">xtea</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#xxtea"><span class="toc-text">xxtea</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#d0tN3t"><span class="toc-text">d0tN3t</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rc4"><span class="toc-text">rc4</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8C%97"><span class="toc-text">逆向工程进阶指北</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#moedaily"><span class="toc-text">moedaily</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#moejvav"><span class="toc-text">moejvav</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sm4"><span class="toc-text">sm4</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ezMAZE"><span class="toc-text">ezMAZE</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Just-Run-It"><span class="toc-text">Just-Run-It</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SecretModule"><span class="toc-text">SecretModule</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cython-Strike-Bomb-Defusion"><span class="toc-text">Cython-Strike: Bomb Defusion</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SMCProMax"><span class="toc-text">SMCProMax</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#xor-%E5%A4%A7%E5%98%98"><span class="toc-text">xor(大嘘)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#babe-z3"><span class="toc-text">babe-z3</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#moeprotector"><span class="toc-text">moeprotector</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B0%83%E8%AF%95"><span class="toc-text">静态调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sub-4010E0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-text">sub_4010E0，以及反反调试</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/getting-your-phone-unlocked/" title="Getting Your Phone Unlocked">Getting Your Phone Unlocked</a><time datetime="2025-04-18T08:09:01.000Z" title="发表于 2025-04-18 16:09:01">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/os-toy-lab-1/" title="操作系统课设实验一">操作系统课设实验一</a><time datetime="2024-10-29T15:06:19.000Z" title="发表于 2024-10-29 23:06:19">2024-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/sys-toy-experiment/" title="计算机组织与体系结构课程设计">计算机组织与体系结构课程设计</a><time datetime="2024-10-20T13:45:50.000Z" title="发表于 2024-10-20 21:45:50">2024-10-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/moectf-2024-reverse/" title="MoeCTF 2024 Reverse">MoeCTF 2024 Reverse</a><time datetime="2024-10-10T13:11:47.000Z" title="发表于 2024-10-10 21:11:47">2024-10-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/rth-roots-over-finite-fields/" title="何以求根">何以求根</a><time datetime="2024-09-06T14:31:34.000Z" title="发表于 2024-09-06 22:31:34">2024-09-06</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgba(0,0,0,0)"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@4.13.0/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@4.13.0/source/js/main.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>